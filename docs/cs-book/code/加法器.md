## 二数加法器

我们简单想来，电路上的加减，就是二进制的加减。  

举个例子：

  01100101​<br>+10110110​<br>----------------<br>100011011

我们使用8位数来实现这个加法器 ，当然可以拓展，这里方便学习



首先需要解决的就是加法的进位问题。  

取一位的加法来看，

其结果的进位，输入输出和 与门 相同。

但是低位的输入输出，和 [异或门](电路升级2.md) 相同

然后这两个门进行组合，可以实现一位的加法，而这个组合成的叫做 **半加器**



再看二位的加法，

除了本来第二位的两个数，再加上从第一位的半加器输出一个进位数c1。

一共有三个数相加。  

拆分一下，先把第二位的两个数，进行半加器输出，低位 s1, 和进位 c2

s1 和 c1 再用半加器输出，低位s2 即当前位，高位c3 要和 c2 再进行一次输出。

想当然的，c3 和 c2 也应该用半加器处理，但是实际上c3 和c2 只可能有一个为1（因为s1和c1只可能一个为1）

所以此时在用一个或门处理c3 c2 即可，得出 进位

这就是 **全加器**



接下来几位的加法如法炮制即可。

如此来看，一个半加器和七个全加器就可以实现 8位的加法器

或者全部使用全加器，同时第一个全加器的 进位输入就设置成0

而如果要拓展连接，则前一个全加器的进位就是后一个全加器的 进位输入



这种加法器，后位的计算依赖于前一位的结果，所以总体速度和位数有关。叫做行波进位（ripple carry）

#### 延伸

还有更快的加法器使用 前置进位 的方式

## 多数加法器

已经满足了两个数之间的加减法，但是如果有多个数需要计算，总不能依次记住每次计算的结果吧。

此时需要一个存储器记录每次加减法的结果，[锁存器](电路升级3,md)符合需求

把8个锁存器连接起来，就是8位锁存器

#### 类型1

1、加法器 对A输入a数，对B输入b数

2、输出结果c

3、存入锁存器C，c从 C输出 到 B端 输入

4、再从 A端 输入d

5、输出结果e 

6、... ...

- 关于时序的控制：

  - 如果是电平触发

    >加法器并没有控制是否 输出的功能，所有怕是要添加一个开关 **控制位**，
    >
    >需要输出加法器结果时，控制位 置为1，锁存器时钟位 置为0，
    >
    >此时数据停留在加法器输出端，
    >
    >需要保存加法器结果时，控制位 置为0，时钟位 置为1
    >
    >此时数据保存在锁存器，并不输出到 加法器
    >
    >再设置控制位 1，时钟位 0
    >
    >... ...

  - 如果是边沿触发

    > 那么输入一次数，关闭一次时钟位即可

- 关于 B 端 同时作为初始数据的输入入口，又作为锁存器数据的输入入口

  实现的关键在于[2-1选择器](电路升级4.md)

#### 类型2

1、加法器 对A输入a数，对B输入锁存器C的全0 初始值

2、输出结果c

3、存入C，输出到B

4、再对A输入d

5、输出结果e

6、... ...

- 关于时序的控制

  参考类型一的时序控制描述。

- 关于处理过一次计算之后，数据的清零问题

  可以将 时钟位 置为1 和 数据位 置为0。

  但电图中，时钟位 常是振荡器，无法精确控制电平

  所以添加一个清零开关，和 D触发器的R输入，经过或门处理，再输入R

  如此保证清零开关 为1时，输出 为0