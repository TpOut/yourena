**时间复杂度**

 因为从复杂度上来讲 _O_\(log2 n\) = _O_\(log10 n\) = _O_\(loga n\) ，所以常量的底可以忽略，简单起见写成_O_\(log n)

![&#x65F6;&#x95F4;&#x590D;&#x6742;&#x5EA6;.PNG](https://upload-images.jianshu.io/upload_images/1936727-77eee6135ad3414d.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

| 算法名称         |                           基本原理                           |          时间复杂度          |
| :--------------- | :----------------------------------------------------------: | :--------------------------: |
| 插入排序         | 区分出已处理部分和未处理部分，在未处理部分依序选择第一个数，依次与已处理部分的数比较，插入到合适的位置 |          _O_\(n^2\)          |
| 冒泡排序         | 区分出已处理部分和未处理部分，在未处理部分一一比较相邻的数，让大数移向已处理部分 | 最佳_O_\(n\)，最差_O_\(n^2\) |
| 归并排序         | 先将数据分成多段，对每个子段递归进行归并排序，再对排好序的子段进行合并排序 |       _O_\(n\*log n\)        |
| 快速排序         | 选取一个数，使左侧部分都小于中间数，右侧部分都大于中间数，再对左右分别递归使用快速排序 |       _O_\(n\*log n\)        |
| 二叉堆排序       | 前提：使用完全二叉树结构，每个结点大于（小于）等于他的子结点。使用上述条件，重复执行获取根结点，并重新排序剩余数据操作 |       _O_\(n\*log n\)        |
| 桶排序和基数排序 |              根据数字的位数的值逐位进行分桶排序              |           _O_\(n\)           |
| 外部排序         | 对无法再内存中处理的大文件数据，类似使用归并排序，先分段排序再逐步归并排序 |       _O_\(n\*log n\)        |
| 选择排序         | 区分出已处理部分和未处理部分，不断从未处理部分中选择最小的数，依次放入已处理部分 |            O\(n)             |

归并排序可以使用多线程并行处理 桶排序在整数时可用，不是比较算法，而其他算法都是比较算法。



**查找**

| 算法名称 |                           基本原理                           | 时间复杂度  |
| :------: | :----------------------------------------------------------: | :---------: |
| 线性查找 |                       逐个一步步的查找                       |   O\(N\)    |
| 二分查找 | 首先需要排序，然后从中间开始比较，如果没有匹配，则从一侧的中间继续比较，直到最后 | O\(log2 N\) |

二分查找的实现方式，可以通过添加两个变量记录下标，来控制选取的列表内容。 

Q1：如果 high 是一个非常大的整数， 比如最大的 int 值 2147483647,\(low + high\)/2 可能导致 溢出。 如何修改从而防止溢出？

A1：可以使用&gt;&gt;&gt;进位符号