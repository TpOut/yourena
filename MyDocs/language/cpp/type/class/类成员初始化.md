假设声明了一个const 变量，

因为声明并不是分配空间，所以没法在声明时赋值

那么只能在构造函数“中”优先赋值，

但是构造函数可能调用多次，出现多次赋值的情况，与

即要在构造函数“初”次调用的时候才赋值

于是就有了 **成员初始化列表**

```c++
Lsj::Lsj(int var): _age(20){}

//引用也需要初始化的需求
Lsj::Lsj(Info & info): _info(info){}
```

变量初始化的顺序和声明相同，而不是按初始化列表顺序



c++ 11 可以在声明时初始化了。。

```c++
class Lsj{
  const int _name = 1;
}
//等价于列表初始化方式
//只是可以被覆盖，如这里 name = 2
Lsj::Lsj(int name): _name(name){}
```



当然常规变量也可以这么使用，而且很多时候会减少创建时间。

比如传递一个string

初始化列表会直接对成员变量调用复制函数初始化，

而常规方式在参数处构造一个，然后赋值时调用赋值函数。



