c 和早期的c++ 中，关键字auto 的用途是指出当前变量为局部自动变量。

c++ 11 中不再允许以这种作用使用。



编译器一般使用三块独立的内存：

一块用于静态变量、一块用于自动变量、另一块用于动态变量

#### 存储（持续性）类型

- 自动存储（栈）, 2种

  函数内部；和方法周期一样

- 静态存储, 3种

  函数外部定义，或者static 修饰；和程序周期一样

- 动态存储（自由空间/堆）

  new 出来的部分；直到delete （或程序退出？）

- 线程存储（c++11）,

  thread_local 声明；和线程周期一样

#### 链接性

自动变量的名称没有链接性，作用域为局部

静态变量的作用域是全局还是局部取决于定义

类中声明的成员的作用域为整个类

类中声明的函数的作用域是类

名称空间中声明的变量的作用域为整个名称空间

> 因为添加了名称空间的概念，全局作用域其实就是 名称空间作用域的一种

名称空间中声明的函数的作用域是名称空间

#### 内存模型

c++ 的存储方式 通过 **存储类型、作用域和链接性** 描述

**自动**

函数中声明的函数参数和变量是，自动，局部，无链接性

自动变量存储时，编译器会在内存中留出一段空间进行管理。

其实现逻辑和栈一样，有一个栈起始指针，有一个栈顶指针，出了一个方法，栈顶指针会被重置到栈起始指针，而没必要进行全部清零操作。

c 和早期c++，auto 显式指出某自动变量是自动的，c++11 中不再允许使用

c++11之前，register 表示建议为寄存器变量，而c++11 中，其作用和之前的auto 相同

**静态**

静态变量默认会被初始化为0

在每个使用外部变量的文件中，都需要定义变量，于是有extern

constexpr //表示在编译的时候就可以计算值，稳定不变

