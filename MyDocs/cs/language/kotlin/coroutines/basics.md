有几个概念，首先coroutine 文中翻作 携程

携程 需要运行在一个叫做CoroutineScope 的上下文内  

> 这个上下文要作为一个类的属性，如全局的GlobalScope

而上下文有对应的方法构造实际的执行代码，如launch 是一个构造器  

launch 返回一个job ，表示这个执行工作，可以通过job 取消工作  



携程运行的上下文继承自运行它的上下文，你可以通过`CoroutineContext` 参数传递额外的上下文信息。上下文信息包括：

- job 实例 - 用于实现结构化嵌套

- 持续性拦截器`ContinuationInterceptor`，如果没有那么使用默认的分发器

可以通过`CoroutineStart` 指定启动选项，如指定懒加载后，会在手动join 或者start 的时候才启动  

 

默认情况下，父job 需要等待子job 结束才能结束

子携程在工作时有未知异常会导致上下文错误，即会导致父携程的工作也被取消

父携程的工作是SupervisorJob 时是个例外，它的子携程失败或取消不会导致它被取消。



携程是轻量级的线程

哪怕重复执行100_000 也没啥问题  





