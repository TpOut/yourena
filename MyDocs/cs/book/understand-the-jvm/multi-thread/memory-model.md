####  **物理并发模型**： 

绝大多数运算任务都不可能只靠处理器 单独计算完成，需要与内存交互（存取）。而处理器和内存的运算速度差距太大。

为此加入高速缓存（Cache），运算前从内存同步到缓存，在运算时直接从缓存存取数据，运算结束后再同步到内存。

而现在多处理器系统中，每个处理器对应一个高速缓存，而所有缓存又共享同一主内存（Main Memory），就有了缓存一致性（Cache Coherence）的问题。

为此加入了一些操作缓存时的协议：MSI，MESI（Illinois Protocol）、MOSI、Synapse、Firefly、Dragon Protocol



由此定义模型：

```mermaid
graph LR
    处理器.. --> 高速缓存.. --> 缓存协议 --> 主内存
    主内存 --> 缓存协议 --> 高速缓存.. --> 处理器..
```

处理器还有额外的乱序执行（Out-of-Order Execution）优化

> Java 虚拟机的即时编译器也有类似的指令重排序（Instruction Reorder）优化

#### **Java内存模型（Java Memory Model, JMM）**

在此之前，主流（C/C++）直接使用物理硬件和操作系统 内存模型，会导致不同平台错误。

而Java 通过添加自己的内存模型来屏蔽物理模型（两者之间通过执行引擎 实现互通）

Java内存模型处理的数据单元，即变量（Variables）和Java 编程中的变量不太一样，它包括实例字段、静态字段、构成数组对象的元素，但不包括局部变量和方法参数。（因为局部变量是线程私有的。注意引用的值不是，引用本身是。）

Java的内存模型结构和物理模型相似：

```mermaid
graph LR
    Java线程.. --> 工作内存.. --> Save/Load --> 主内存
    主内存 --> Save/Load --> 工作内存.. --> Java线程..
```

主内存：和物理模型名称相同，但只是虚拟机内存的一部分；

工作内存（Working Memory）：对应每条线程，其保存了被线程使用到的变量的主内存拷贝（当然只是引用和访问到的字段的拷贝，不是大容量整体拷贝）。volatile 也不能避免拷贝



从更低的层次说，主内存就直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机（甚至是硬件系统本身优化）会让工作内存优先存储于寄存器或高速缓存中



#### **内存模型操作**

操作列表：

- lock : 作用于主内存，把一个变量标识为一条线程独占
- unlock ：同上，把一个处于lock状态的变量释放出来，让其他线程锁定
- read : 作用于主内存，把变量值从主内存传输到工作内存，方便后续 load
- load : 作用于工作内存，把read 获取的变量值 放入工作内存的副本中
- use : 作用于工作内存，把工作内存的变量值 传递给执行引擎。每当虚拟机遇到一个需要使用这个变量值的字节码指令时会执行这个操作
- assign : 作用于工作内存，把执行引擎接收到的值赋给工作内存的变量。虚拟机，赋值字节码，执行
- store : 作用于工作内存，把工作内存中的变量值传到主内存中，方便后续write
- write : 作用于主内存，把store 获取的变量，放入主内存的变量

看的出来，load 必须在read 之后，write 必须在store 之后；

但是没有规定read  和load 之间；store 和write 之间不能有其他操作

所以读取a,b 变量的操作可能是， read a ,read b, load b , load a



除double 和long 类型的 load,store,read,write 操作在某些平台上有例外，

其他时候所有操作必须保证原子性，和一些约定：

- read 之后必须 load,  store 之后必须write
- 线程不能丢弃最近一次assign操作的结果，即必须同步数据回主内存；线程没有assign 操作的情况下，不允许同步数据回主内存
- 一个新的变量只能在主内存中产生，不允许工作内存直接使用一个未被初始化的变量。就是说，在use\store 一个变量前，必须先assign/load 
- 一个变量在同一时刻，只允许一个线程对其lock，但lock 次数不限。unlock 次数必须对应才能解锁
- <font color=red>如果对一个变量执行lock 操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load 或者assign 操作初始化变量的值</font>（如果请求锁的时候，分配器将锁分配给当前变量之前，会让其他相关线程同步数据，那么此时这个清空操作就能理解了。如此能保证数据一致性，称为内存屏障（memory barrier / memory fence）。同时因为其他线程的同步数据操作，相当于保证了其他线程的乱序优化也一定在锁相关代码之前被执行完毕）
- unlock 不允许对未lock 的变量执行，也不允许其他线程unlock 当前线程的lock
- 对一个变量执行unlock 操作，必须先把变量同步回主内存



由于long和double 是64位的有些特殊性，规范允许将没有volatile 修饰的64位数据的读写操作划分为两次32位的操作来进行。但是实际上没有非原子性的实现



#### 内存模型特性

**原子性：**基本类型的访问读写是具备原子性的。而lock/unlock 也是，但是需要上层synchronized来添加字节码指令（monitorenter, monitorexit），此时synchronized 包裹的代码块之间的操作也具备原子性。

**可见性：**当一个线程修改了某个共享变量的值，其他线程能够立即得到这个修改。除了volatile之外，还有synchronized 和final 可以保证可见性。

**有序性：**单线程而言，所有操作都是有序的（线程内串行-- Within-Thread As-If-Serial Semantics）；如果在一个线程中观察另一个线程，那么就是无序的（指令重排序，工作内存和主内存同步延迟）。



**先行发生（happens-before）原则**

