```c++
int rats;
int & rodents = rats; //复制一份引用，作为别名，但是两者指向相同的值和内存，互相影响修改
```

引用初始化时必须赋值，此时包括值和地址，而之后不能改变地址。只能赋值

```c++
int rats = 101;
int * pt = &rats;
int & rodents = *pt; //注意此时rodents，自动会赋值 rats 的地址和值
int bunnies = 50;
pt = &bunnies; //并不影响rodents，不会变化。
```



早期的编译器允许 表达式传递给 函数作为引用参数，会产生一个**临时变量**。

这个临时变量显然不会修改原数据。不修改原数据和 引用的初衷不同。

所以现代c++ 标准严格要求临时变量的创建：

只有在参数是 const引用（即不修改），且实参不匹配的时候（不匹配 包括类型正确但不是左值、类型不正确但可以转化），才允许 生成临时变量。



不要把方法里的变量，传递给引用结果。（会变成空）



#### 右值引用

c++11

这种引用可以指向右值，使用&& 声明（如此之前的就叫做左值引用）：

```c++
double && r_ref = std::sqrt(36.00);
double j = 15.0;
double && jref = 2.0*f + 18.5;
```



#### 类引用

基类引用可以指向派生类

