c++ 不能在方法中返回 数组类型  



argument 表示实参，parameter 表示行参



（当且仅当）在函数头/原型中，int * 和 int [] 的含义是相同的

此时 ` arr[i] = *(arr + i) ; &arr[i] = arr + i;`

而二维数组的原型等同是：`int sum(int ar[][4]) ; int sum(int (*ar2)[4])`



指针参数尽量使用const 修饰，一个是可以避免出错；一个是实参可选const 和非const，范围更广

但是二级指针不要使用const，具体参看[const 一文]()



std::initialize_list；可以表示任意长度的列表，即可变参数

#### 原型

函数要定义原型

除了能让编译器“察觉”返回类型和参数的匹配情况，

还能让编译器在执行之前，将一个地址设定为返回值的地址，执行方法之后产生的值会被放入这个地址。

> 关于为什么不直接全文查找方法定义
>
> 一是因为效率不高
>
> 还有可能是函数不在源文件中，可能编译器无权访问相关的函数代码。



c++ 中一定要声明函数原型，但是把定义和原型写在一起，或者分开来不是很关键。

原型若不指定参数列表，则应使用省略号：`void func(...)` ，一般只有和c的可变参函数交互才会用到

#### 递归

不允许main递归

#### 内联函数

```c++
inline double square(double x){return x * x};
//使用时不再分开写函数的原型和定义，直接把整个实现放在本来原型的地方。
int main() ...
```

常规函数需要跳转地址调用，而内联函数把函数代码在每次运行的地方都复制一份，不再需要跳转，速度稍快。

有些编译器会有自己的考虑，比如监测到函数过大，或者调用了自己（内联函数不能递归），则会忽略inline。

#### 默认参数

```c++
//原型设置即可，定义不需要。默认参数需从右到左
char * left(const char * str, int n = 1);
```

#### 函数重载

无法区分引用非引用，故两者算同一特征；方法的特征不包含返回类型

非const 可以传递给非const 和const；而const 只能是const

![image-20191023212728472](image-20191023212728472.png)

#### 函数模版

```c++
//c++98 之后，typename 替换了class 关键字，即后者也可
template <typename T>
void f(T a, T b){
  T temp;
  ...
}
//在使用的时候，调用方法f 会产生对应的方法实例，比如
int a,b;
f(a,b);
//实际上是编译器隐式的创建了f 的int 实例
template void f<int>(int,int);
//但是不是所有时候都适合，比如
int a; double b;
f(a, b);
//此时编译器不知道创建啥，需要我们显式指出实例
main{
  template void f<double>(double, double); //调用前实例化即可
  f(a, b);
}

//模版中有些操作可能不适用于所有的类型 T
//此时有一种具体化的解决方案：**显式具体化模版函数**
//这样就可以把传入的类型 限定在job 及其子类
template<> void swap<job>(job &, job &); //<job> 可选，因为可推断
```

多个原型匹配的时候，编译器优先选择非模版函数，次选显式具体化，最后是模版函数

**decltype**

```c++
//c++ 98中无法知道xplusy 的类型
template<class T1, class T2>
void ft(T1 t1, T2 t2){
  ??? xplusy = t1 + t2;
}
//c++ 11
decltype(t1 + t2) t1plust2 = t1 + t2; //这里前面括号里的 t1+t2 并不会调用
```

关于具体语法规则，主要也是编译器处理，有兴趣看 原文8.5.6 第2小节

```c++
decltype(exp) var; //var 是名称，前面是修饰
```

**后置返回类型**

```c++
//上面的语法还是无法解决如下情况，因为返回时，t1 和t2 已经无效
template<class T1, class T2>
??? ft(T1 t1, T2 t2){
  return t1 + t2;
}
//c++11
auto ft(T1 t1, T2 t2) -> decltype(t1 + t2){
  ...
}; //这种语法也可以用于常规函数
```

#### 函数重载

重载解析（原文8.5.5），比较细，属于编译器逻辑，有兴趣再深入