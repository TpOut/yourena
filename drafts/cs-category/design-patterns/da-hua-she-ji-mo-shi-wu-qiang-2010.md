

#### 适配器模式（Adapter）

场景主要还是对接两方代码的时候，对两者之间功能类似但是接口不一致的处理。  

#### 外观模式（Facade）

基本上是把多个业务底层类的操作，嵌套一层进行高层次的统一调用。

但是示例中根本就没有实现接口。。。

#### 组合模式 （）

以树的形式，用管理类持有多个被管理类，管理类和被管理类继承相同的接口。即行为基本一致  
然后调用相同的行为时进行递归处理

#### 桥接模式（Bridge）

把本可能属于一个物品的属性，拆分开需要独立变化的部分，以更好的处理变化。

#### 责任链模式

责任链模式，本身并不创建责任链。  
纯责任链：不能对责任进行部分承担，而后传递给下家，且必须被某个处理者接受。

#### 单体模式\(Singleton\)、多例模式

饿汉、懒汉单例模式  
多例模式即可能有多个实例的单体类，需要自己管理。

#### 观察者模式

根据是否有参数，还分了推、拉。。。感觉有点多余

#### 状态模式

通过继承和持有自身状态类，在触发时执行方法更改状态类。

#### 中介者模式

在多个对象之间加入一个中介对象，来处理各个对象之间的逻辑关系。

#### 代理模式

使用接口抽象某个类，然后继承接口并持有类对像，实现拓展。

动态代理。

#### 享元模式（FlyWeight）

感觉有点像obtain\(\)

#### 构造型模式

??? 介绍了一下类的构造器？

#### 生成器模式（Builder）

#### 工厂方法模式

这个感觉是在知道业务场景之后，再进行抽象

#### 抽象工厂模式

#### 原型模式（ProtoType）

就是深度clone。。。

#### 备忘录模式

就是备份？

#### 操作型模式

？？？ 又是啥都没讲，说调用方法，多态。。。

#### 模板方法模式  \(Template\)

即逻辑确定的抽象

#### 状态模式

用自身类来保持状态。。

#### 策略模式  \( Strage\)

就是把某些行为抽取成类，然后持有引用

#### 命令模式 \(Command\)

还是将共同行为抽象

#### 解释器模式\(Intercept\)

#### 拓展型模式

就是继承、持有

#### 装饰器模式（Decorator）

装饰接口抽象，并在实现某个装饰时持有被装饰者的引用

#### 迭代器模式

visitor模式准备：静态分派，动态分派，多分派，单分派

