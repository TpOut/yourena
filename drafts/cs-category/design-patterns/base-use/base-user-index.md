为了更好的理解，我们先编写一个迷宫游戏。

基本需求为：

- 迷宫的组成为房间，房间的组成是墙或者门，起码有一扇门。门的两边可能是房间或者出口。出口只有一个。

- 初始化时，玩家随机在某个房间中，通过上下左右在迷宫中移动
- 简单模式（全图可见）
- 进入模式（随意移动）

可能需求：

- 修改迷宫界面
- 进入模式（门密码，房间炸弹）
- 中等模式（路径可见），困难模式（当前可见）



按基本需求先写，为了简化，迷宫大小为4，代码为版本1。



[抽象工厂(Abstract Factory)](./abstract-factory.md)

适配器(Adapter): 将一个类的接口转换成客户希望的另外一个接口。（主要用于原始接口不兼容）

桥接(Bridge): 将抽象部分和实现部分分离，使他们都可以独立的变化

构建者(Builder)

责任链(Chain of Responsibility): 将处理请求和结果处理成一条链，减少耦合。

命令(Command): 将一个操作封装成一个对象，将其参数化。

复合(Composite): 单个对象和复合对象的使用具有一致性

装饰者(Decorator): 动态的给一个对象添加额外的修饰

外观(Facade): 为子系统中的一组接口提供一个一致的界面

工厂方法(Factory Method): 让子类决定实例化哪个类

享元(Flyweight): 用共享技术有效地支持大量细粒度的对象

解释器(Interpreter): 定义一种文法和解释器

迭代器(Iterator): 提供统一的方法顺序访问一个聚合对象中的各个元素。

中介(Mediator): 用一个中介对象封装一系列的对象交互

备忘录(Memento): 不破坏封装性的前提下，在对象外部保存对象内部状态。

观察者(Observer): 保存对象的1对多关系，在对象改变时通知观察者

原型(Prototype): 原型拷贝

代理(Proxy): 代理对象的控制

单例(Singleton): 全局一个实例和访问点

状态(State): 允许一个对象在其内部状态改变时改变他的行为

策略(Strategt): 封装算法，使可替换

模板方法(Template Method): 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中

访问者(Visitor): 表示一个作用于某对象结构中的各元素的操作



| 模式名称 | 适用问题 | 解决方案 | 效果 |
| -------- | -------- | -------- | ---- |
|          |          |          |      |

