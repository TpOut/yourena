- 先看问题2

我们希望有一个 **中止位**，可以让 计数器 恰逢其时的终止

那中止位在 预置RAM 数据的时候，就应该知道

而且为了自动化的需求，中止位必须是读取出来的，鉴于RAM中存储的数据可能是任何值，所以需要增加一个RAM用来存储 操作指令。后续称两个RAM 一个为**存储RAM**， 一个为**指令RAM**



所以假设要存入3个数字，在存储RAM 地址0001，存入1，0002存入2，0003存入3；

想要终止，很简单，在指令RAM 地址0001，存入非0 的数即可，只要读取即认为 终止

但是数有时候是3个，有时候是2个，怎么知道执行到第几个数终止呢？

只需要在对应的位置存储即可，如此时3个数，则在 指令RAM 的0003 位置存入 非0数



有中止，必然有开始，否则存储RAM 的数据只能计算一次，而一次计算通常来讲只有几个数据，那么会造成存储的极端浪费。



先举例分析一下多次计算的部分：

先对3个数字求和，停止，再对2个数字求和，停止

这里开始第二次计算相当于又需要一个指令，先姑且叫做 开始

因为已经有了两个指令，要对指令进行编码来区分，设定 **中止**是 ffh，**开始**是01h（书上没讲，笔者随便举了个例子）



多了多次计算，延伸出另一个问题，结果的存储。

此时每次计算的值并不会马上输出使用，所以必须把每次计算的值都存储起来，方便以后获取使用。

因为存储RAM 本身就是存储用的，所以干脆把结果放在每次求和之后，即如果是3个数，则第4个人可以用来存储结果。而显然此时，又需要一个指令来表示：**存储** 11h



- 再看问题1

如上的思路，解决了操作的控制问题。

之前想过，如果要解决溢出问题，应当是将8位拓展成16位，但是这种方式成本不仅过大，而且无限制。

更优秀的方式应该是把 16位拆分成2个8位，然后通过指令粘连在一起。如此又多了 **进位加法** 22h

再并入减法，多了 **加法** 20h、**减法** 21h、**借位减法** 23h

> 此处不再细解，具体的实现从 p219 开始，
>
> 开始01h 在书中没有提及，而是另一个指令 加载10h；中止 叫做 停止
>
> 且思路不尽相同



