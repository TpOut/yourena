**GC Root 枚举**

目前为止，所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的。

为了减少停顿时间（减少枚举时间），hotspot 是使用一组OopMap 的数据结构，在类加载动作完成的时候，记录对象内存中每段偏移量对应的类型数据；即时编译的过程，也会在特定的位置记录下栈里和寄存器哪些位置是引用。



**安全点**

OopMap 同时会带来存储空间的额外消耗，如果引用关系变化的情况比较多，是否还需要根据变化经常更新OopMap呢？实际上是不需要的，这里有一个安全点的概念。

选取一个线程执行的安全点，在收集器想要收集的时候，让线程执行到安全点再暂停。这样就不需要理会中间过多的变化。暂停有两种，抢先式中断和主动式中断。



**安全区域**

目前基本都是主动式中断的实现方式，即线程自我轮询 是否有垃圾收集标志。但是如果线程当前不在执行状态，就无法实现主动式中断，此时需要引入安全区域的概念。



**记忆集**

一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构，

最简单的实现可以用非收集区域中所有含跨代引用的对象数组来实现，但是用对象来维护，成本非常高昂。而收集器只需要知道是否存在跨代引用即可。

对应可行的集合的项目粒度可以是：

- 字长，精确到一个机器字长，字包含跨代指针
- 对象，精确到对象，对象字段包含跨代指针
- 卡，精确到一块内存区域，区域内有对象包含跨代指针

目前最常用的实现是“卡”，只要内部有对象包含跨代指针，整个卡被标识为“脏”，垃圾回收时再把他们加入GC Roots 进行扫描。



**写屏障**

卡表元素何时变“脏”是比较明确的，只要被跨代引用时。但是具体实现上，由于编译执行后产生的是机器指令流，所以需要在机器码层面的手段。

卡表元素的维护在hotSpot 中通过“写屏障”来处理，可以理解成虚拟机层面对“引用类型字段赋值”这个动作的AOP切面。这个切面包括了 写前屏障，写后屏障。

“伪共享”问题，伪共享是处理并发底层细节时一种要考虑的问题：现代中央处理器的缓存系统中是以缓存行（Cache Line）为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影响（写回、无效化或者同步）而导致性能降低。

对于“伪共享”问题，可以根据实际情况考虑，增加“脏”数据标记判断，但也增加了判断消耗。



**并发可达性**

上述GC Roots 的枚举问题已经实现的差不多了

接下来是GC Roots 的可达性分析，由于复杂的堆对象，这势必是一个非常“耗时”的操作



再回过头我们仔细理解下，为什么必须在一个能保障一致性的快照上才能进行对象图的遍历？

从某个节点开始有序遍历，首先用白色表示对象尚未被访问过；灰色表示对象被访问过，但是至少存在一个引用还没有被扫描；黑色表示对象被访问过，且引用也都被访问过。

理论上，这种模型只有下述情况才会出现问题：

- ```mermaid
    graph LR
        black --> gray --> white
    ```

- 赋值器插入了一条或多条从 黑色->白色 的新引用；赋值器删除了全部从灰色到该白色的直接或间接引用。 

- ```mermaid
    graph LR
        black --> white
        black -.-> gray
        gray -.-> white
    ```

所以如果能解决这种场景的问题，就可以实现并发处理。而解决这个问题的关键，是让两个条件不能同时出现。

针对插入 黑色-> 白色 的引用，使用增量更新方案：在扫描过程中的变化做记录，扫描后对记录中的部分再次扫描。

针对删除 灰色-> 白色 的引用，使用原始快照方案：在扫描过程中的变化做记录，扫描后对记录中的部分再次扫描。



调优

5.2节做了一些服务端案例分析	

安全点导致长时间停顿，可数循环

5.3节做了一些客户端案例分析

这一部分跳过了



---

三色标记（Tri-color Marking）