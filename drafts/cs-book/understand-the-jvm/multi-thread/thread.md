线程细分了进程的资源分配和执行调度：各个线程可以共享进程资源；又可以独立调度（线程是cpu调度的基本单位）

java 的`Thread` 类则是java 对不同硬件和操作系统平台的封装，可以注意到关键的方法都是native 实现。



底层实现线程主要有3种方式：

- 内核线程（Kernel-Level Thread）

    操作系统内核直接支持，即多线程内核。内核操作调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身，以此同时处理多件事情

    程序一般不会直接使用内核线程，而是使用内核线程的一种高级接口 -- 轻量级进程（Light Weight Process）来实现线程，它们是1对1关系。而每个LWP 都需要一个内核线程支持。

    > 局限性：线程操作需要系统调用（切换型态如用户态和内核态）资源代价较高；数量上限较低

- 用户线程（User Thread）

    广义上讲，只要不是KLT ，就是UT -- LWP 也属于UT。

    狭义上讲，完全建立在用户空间的线程库上才是UT，让内核完全无感知。

    > 局限性：内核线程调度的支持逻辑需要程序（线程库）自己实现。

- UT混合LWP

    结合上述两种方式，取优点：减少调度逻辑的处理；增加线程数量上限



java线程的实现，则是基于操作系统原生线程模型来实现。即open jdk在linux 上是1：1的模型。



线程的调度，指系统为线程分配处理器使用权的过程。主要分为：

- 协同式线程调度(Cooperative)

    由线程自身控制执行。在线程执行任务完毕之后，需要主动通知系统，以切换另一个线程。

- 抢占式线程调度(Preemptive)

    由系统分配执行。阻塞唤醒时也需要切换型态（用户态，核心态）

java使用抢占式



java线程状态：

- 新建（New）：创建而未启动

- 运行（Runnable）:包括操作系统线程状态中的Running（正在执行） 和Ready（等待分配）

- 无限期等待（Waiting）:不会被分配执行时间，需要被显式唤醒。

    进入方式：没有设置Timeout 的Object.wait()、没有设置Timeout的Thread.join()，LockSupport.park()



**Thread Api**

thread 的start 发生于thread 内的任何动作之前

thread 的join \ isAlive 检测，发生于thread 内的任何动作之后

thread 的interrupt 发生于thread 内检测到中断异常 之前，

yield 方法可以让出执行时间，

优先级，非精准可靠性。



wait, notify, notifyAll

