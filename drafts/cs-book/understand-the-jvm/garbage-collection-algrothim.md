垃圾回收算法细节化、差异化很大，这里只讲思想



**分代收集**（Generational Collection）

当前大多数虚拟机都遵循此方案。但是后续的理念是去除分代的全区域收集

分代的前提有两个：

- 弱分代假说（Hypothesis）：绝大多数对象都是朝生夕灭
- 强分代假说：熬过越多次垃圾收集过程的对象越难以消亡

再加上引用标记需要一定资源消耗，所以垃圾回收会将堆划分出不同的区域，集中处理不同分代强度的对象能够兼容时间和空间

对应区域的不同分代，垃圾收集器可以对应执行“Minor GC” -- 新生代,"Major GC" -- 老年代,"Full GC" -- 全部，前两者又叫做部分收集（部分收集还包括mixed gc，只在g1收集器上存在，全新生代，部分老年代）

而同时因为区域的划分，具体的算法可以更有针对性，对应“标记-复制算法”，“标记-清除算法”，“标记-整理算法”



对应不同代，HotSpot 叫做新生代和老年代（也有叫婴儿区、长存区），新对象创建后在新生代中，垃圾收集后大批新生代对象死去，存活下来的对象逐步晋升到老年代中。



主要的问题在于对象的跨代引用

如果只局限于新生代区域的收集，即是Minor GC，但是为了找出老年代中是否有引用新生代对象，需要同时遍历老年代，因此需要添加另一个分代前提：

- 跨代引用假说：跨代引用相对于同代引用来说仅占极少数

    因为如果新生代没有死亡，就应该进入老年代

所以这种极少数的情况，我们就没必要做全局遍历，只需要在新生代上建立一个全局的数据结构（如记忆集，Remembered Set），用于将老年代划分为若干小块并标识跨代引用的部分，在后续Minor GC 时，只对该小块进行扫描。



**标记算法**

- 标记 - 清除（Mark-Sweep）

    就是单纯的对需要收集或不需要收集的对象进行标记

    缺点：

    1、直接对标记对象进行清除，会导致空间碎片化严重，继而导致下次gc 变短

- 标记 - 复制

    区域划分可分配内存。标记的前提下，将一部分区域作为新生代分配空间，一部分区域作为存活对象的目标空间，当对象挺过gc，则从新生代空间复制到目标空间，再清除新生代空间。

    而区域的划分，最初是“半区划分”：1：1，而后改进为Appel式回收：一块大区称为Eden区，两块小区称为Survivor区。其中Eden区和一块Survivor 区作为新生代分配空间，另一块Survivor区作为存活对象目标空间。

    hotspot 默认Eden :Survivor :Survivor 是8:1:1，但是没人能保证90%一定够用，所以针对特殊情况有个“逃生门”的安全设计：当Survivor 空间不足容纳存活对象时，会依赖其他内存区域（基本就是老年代区域）进行担保

    缺点：

    对象存活过多时，复制消耗过大；还需要进行担保。

- 标记 - 整理

    标记的前提下，对存活的对象进行移位集中化整理，然后将存货对象边界以外的对象 -- 即死亡对象 清除。

    但是这种移动操作也非常繁重，同时还要停止应用程序的执行。



标记法都有一个缺点：由于标记和对象收集数对应，所以总体的执行效率不稳定。

关于标记清除的内存不连续问题，可以通过内存分配器和内存访问器解决（如分区空闲分配链表，专门处理非连续物理空间）。而这种方法相对于 标记整理带来的程序整体吞吐量下降是更大的

也有一些算法，如CMS收集器使用的，是多数时候容忍碎片化，即使用标记清除；在某次影响对象分配时，再进行标记整理。



IBM 量化新生代“朝生夕灭”：常规情况下，新生代对象有98% 熬不过第一轮收集。



[hotspot 的算法细节](./hotstop.md)

Q：Appel式回收中 目标区域Survivor 中的对象叫啥？过程代？

---

Richard Jones撰写的《垃圾回收算法手册》[插图]的第2～4章的相关内容。