[Jni框架](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html)

jni heap可以在内存分析器里查看

jni交互设计理念（按序降低优先级）：
- 减少跨jni层面的资源交互(marshll)
- 禁止j-code和native异步交互。你可以在j-code开启一个子线程，然后执行native的阻塞代码，并在执行完之后回调主线程进行ui更新。
- 减少native的线程数。实在不行，最好是native自己管理线程，而不是让native和j-code之间的线程各种交互
- 接口相关的定义尽量少一些标识以增加维护性。比如用自动生成的

## JavaVM和JNIEnv
jni定义了两个关键数据结构，‘JavaVM’和‘JNIEnv’。
两个本质上都是指向  指向方法表的指针  的指针
（In the C++ version, they're classes with a pointer to a function table and a member function for each JNI function that indirects through the table）

JavaVM 提供了调用接口函数，允许你创建和销毁JavaVM，理论模式可以在一个进程创建多个JavaVM, 只是Android 限制只能有一个
JNIEnv 用于thread-local存储，所以不能在多个线程内共享JNIEnv。实在没办法的话，就通过共享JavaVM，然后用`GetEnv`

两者在C和c++ 中的定义不同，即`jni.h`中定义的类型不同。
所以最好不要把JNIEnv放到头文件里

## 线程
都是linux线程
一般使用Thread.start启动，但是也可以：
```
//创建
pthread_create
//附着
AttachCurrentThread
AttachCurrentThreadAsDaemon
//这种方式必须 去除附着
DetachCurrentThread
```
```
//如果手动去除比较嫌烦
//用这个创建
pthread_key_create

//他会构建一个自动析构的方法，里面自己会调用DetachCurrentThread
//携带pthread_setspecific 参数
```

attach native创建的线程会创建一个java.lang.Thread 对象，并加入到"main" ThreadGroup
Android不会挂起正在执行的native代码，即调试的时候会直接跳到下一次jni调用

## 获取jclass, jmethodID, and jfieldID
FindClass;GetFieldID,GetIntField

jclass是一个类引用，id一般性只是指向内部运行时数据结构的指针
```
//正确的初始化方式
private static native void nativeInit();

    static {
        nativeInit();
    }
```

### 本地和全局引用
方法传递的参数，返回的对象都是本地引用
jobject的子类包括： jclass, jstring, and jarray

而全局引用必须通过 NewGlobalRef 或 NewWeakGlobalRef 方法来提升作用域
```
jclass localClass = env->FindClass("MyClass");
jclass globalClass = reinterpret_cast<jclass>(env->NewGlobalRef(localClass));
```
示例如上，当想取消的时候调用 DeleteGlobalRef

全局提升后的引用和原先的本地引用不是一个引用，比较两个引用使用IsSameObject，而不是== 单纯比较引用的对象
如果本地对象太多，可以主动使用 DeleteLocalRef
EnsureLocalCapacity/PushLocalFrame

jfieldIDs 和 jmethodID 不是对象引用，而是一种(opaque)类型，不能被全局提升 。
GetStringUTFChars/GetByteArrayElements

所有native线程loop中的本地引用都记得手动消除

## UTF-8/16 字符串
java使用UTF-16，stirng不是以\u0000 结尾的
而jni为了简便，方法是基于Modified UTF-8的，\u0000是0xc0 0x80（而不是0x00）

因此 GetStringUTFChars 需要注意字符串的长度
一些返回 jchar*/jbyte* 的方法结果，是原始数据而不是本地引用
同时调用Get* 之后记得 Release*

NewStringUTF的参数必须是Modified UTF-8 格式

## 原始数组

---- toread ----
